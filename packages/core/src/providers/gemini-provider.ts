import {
    BaseImageModelProvider,
    AIProviderConfig,
    AIGenerationRequest,
    AIGenerationResponse,
    AIProviderError,
} from '../base-provider'

// Gemini API types
interface GeminiPart {
    text?: string
    inlineData?: {
        mimeType: string
        data: string
    }
}

interface GeminiContent {
    parts: GeminiPart[]
}

interface GeminiRequest {
    contents: GeminiContent[]
    generationConfig: {
        temperature: number
        maxOutputTokens: number
        topP: number
        topK: number
    }
}

interface GeminiCandidate {
    content: {
        parts: Array<{ text: string }>
    }
    finishReason: string
    safetyRatings: unknown[]
}

interface GeminiResponse {
    candidates: GeminiCandidate[]
    usageMetadata?: {
        promptTokenCount: number
        candidatesTokenCount: number
        totalTokenCount: number
    }
}

/**
 * Google Gemini AI Provider
 * Supports image and text inputs for game asset assistance
 */
export class GeminiImageProvider extends BaseImageModelProvider {
    private static readonly DEFAULT_MODEL = 'gemini-2.0-flash-exp'
    private static readonly API_ENDPOINT =
        'https://generativelanguage.googleapis.com/v1beta/models'

    constructor(config: AIProviderConfig = {}) {
        super('gemini', GeminiImageProvider.DEFAULT_MODEL, config)
    }

    /**
     * Generate a response using Gemini API
     */
    async generateResponse(
        request: AIGenerationRequest
    ): Promise<AIGenerationResponse> {
        if (!this.isConfigured()) {
            throw new Error(
                'Gemini provider is not configured. Please provide an API key.'
            )
        }

        const endpoint =
            this.config.endpoint || GeminiImageProvider.API_ENDPOINT
        const model = this.getModel()

        try {
            const response = await this.callGeminiAPI(endpoint, model, request)
            return this.parseGeminiResponse(response)
        } catch (error) {
            throw this.handleGeminiError(error)
        }
    }

    /**
     * Check if the provider has the required configuration
     */
    isConfigured(): boolean {
        return !!this.config.apiKey
    }

    private async callGeminiAPI(
        endpoint: string,
        model: string,
        request: AIGenerationRequest
    ): Promise<GeminiResponse> {
        const url = `${endpoint}/${model}:generateContent?key=${this.config.apiKey}`

        const parts: GeminiPart[] = [
            {
                text: this.buildPrompt(request),
            },
        ]

        // Add images if provided
        if (request.images && request.images.length > 0) {
            for (const image of request.images) {
                parts.push({
                    inlineData: {
                        mimeType: this.detectMimeType(image),
                        data: this.extractBase64Data(image),
                    },
                })
            }
        }

        const body: GeminiRequest = {
            contents: [
                {
                    parts,
                },
            ],
            generationConfig: {
                temperature: request.temperature ?? 0.7,
                maxOutputTokens: request.maxTokens ?? 1000,
                topP: 0.8,
                topK: 10,
            },
        }

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
        })

        if (!response.ok) {
            const errorData = await response
                .json()
                .catch(() => ({ error: { message: 'Unknown error' } }))
            throw new Error(
                `Gemini API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`
            )
        }

        return response.json() as Promise<GeminiResponse>
    }

    private buildPrompt(request: AIGenerationRequest): string {
        let prompt = ''

        if (request.systemPrompt) {
            prompt += `System: ${request.systemPrompt}\n\n`
        }

        prompt += `User: ${request.prompt}`

        return prompt
    }

    private parseGeminiResponse(
        response: GeminiResponse
    ): AIGenerationResponse {
        const candidate = response.candidates?.[0]
        if (!candidate) {
            throw new Error('No response generated by Gemini')
        }

        const text = candidate.content?.parts?.[0]?.text || ''

        return {
            text,
            usage: response.usageMetadata
                ? {
                      promptTokens:
                          response.usageMetadata.promptTokenCount || 0,
                      completionTokens:
                          response.usageMetadata.candidatesTokenCount || 0,
                      totalTokens: response.usageMetadata.totalTokenCount || 0,
                  }
                : undefined,
            metadata: {
                finishReason: candidate.finishReason,
                safetyRatings: candidate.safetyRatings,
            },
        }
    }

    private handleGeminiError(error: unknown): AIProviderError {
        if (error instanceof Error) {
            // Extract structured error information if available
            if (error.message.includes('API key')) {
                return {
                    code: 'INVALID_API_KEY',
                    message: 'Invalid or missing Gemini API key',
                    originalError: error,
                }
            }

            if (error.message.includes('quota')) {
                return {
                    code: 'QUOTA_EXCEEDED',
                    message: 'Gemini API quota exceeded',
                    originalError: error,
                }
            }

            return {
                code: 'GEMINI_ERROR',
                message: error.message,
                originalError: error,
            }
        }

        return {
            code: 'UNKNOWN_ERROR',
            message: 'Unknown error occurred with Gemini provider',
            originalError: error,
        }
    }

    private detectMimeType(imageData: string): string {
        if (imageData.startsWith('data:')) {
            const mimeMatch = imageData.match(/data:([^;]+)/)
            return mimeMatch?.[1] || 'image/jpeg'
        }

        // Default to JPEG for base64 without data URL prefix
        return 'image/jpeg'
    }

    private extractBase64Data(imageData: string): string {
        if (imageData.startsWith('data:')) {
            const base64Match = imageData.match(/base64,(.+)/)
            return base64Match?.[1] || imageData
        }

        return imageData
    }

    /**
     * Test the connection to Gemini API
     */
    async testConnection(): Promise<boolean> {
        try {
            const response = await this.generateResponse({
                prompt: 'Hello, test connection',
                maxTokens: 10,
            })
            return !!response.text
        } catch {
            return false
        }
    }

    /**
     * Get available models (placeholder - would need separate API call)
     */
    static getAvailableModels(): string[] {
        return [
            'gemini-2.0-flash-exp',
            'gemini-1.5-flash',
            'gemini-1.5-pro',
            'gemini-1.0-pro-vision',
        ]
    }
}
